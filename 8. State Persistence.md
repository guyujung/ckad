# volumes

pod는 일시적인 것이라 pod를 삭제할때 volume도 같이 사라집니다.

## hostPath

같은 node에서 volume이 생겨납니다. volume을 생성하고 mount를 합니다.
hostPath는 단일 노드에서는 괜찮지만, 멀티 노드 환경에서는 권장하지 않습니다.


## persistent volume


   저장소를 중앙에서 관리합니다.
   pvc로 pv에 있는 리소스를 사용합니다.

```
   apiVersion: v1
kind: PersistentVolume
metadata:
    name: pv-vol1
spec:
    accessModes:
        - ReadWriteOnce
    capacity:
        storage: 1Gi
    awsElasticBlockStore:
        volumeID: <volume-id>
        fsType: ext4
  ```

### binding

 selector와 label로 특정 pv를 바인딩 할 수 있습니다.
  
 다른 선택지가 없다면 요청했던 것보다 더 큰 pv가 바인딩 될 수 있습니다.
```
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: myclaim
spec:
    accessModes:
        - ReadWriteOnce
    resources:
        requests:
            storage: 500Mi
```


persistentVolumeRecalimPolicy: Retain 볼륨을 어떻게 할지 선택 가능합니다.

# storage clasee

volume의 동적 프로비저닝


storage가 동적으로 pv를 준비하기 때문에 pv 정의가 더 이상 필요하지 않습니다.
pv를 더 이상 수동으로 생성하지 않고 자동으로 생성 가능합니다.

# stateful set


기존의 데이터베이스의 데이터를 새 서버의 새 데이터베이스로 어떻게 복제할까요?

1. master - slave로 복제
   단점: 여러 slave와 연결을 해야하기 때문에 master의 네트워크 인터페이스 성능에 문제를 일으킬 수 있습니다.

2. slave가 2개 있다면 첫번째 slave가 master로 부터 복제되고 두번째 slave가 첫번째 slave로 부터 복제됩니다.
   그 이후에 master와 연결해서 지속적으로 업데이트 됩니다. 두 개의 slave들은 master의 ip주소로 구성되어 있습니다.

그러나 이 복제 과정을 구현 하려면 master와 slave를 구분해야 하는데 deployment로는 불가능 합니다.
pod의 ip는 유동적이니까 ip로 식별 불가능하고 고정 호스트 이름이 필요합니다.
pod가 무작위로 이름을 지어서 여기서는 도움이 안됩니다.

이를 해결하기 위해 stateful set이라는 것이 나왔습니다. statefulset은 템플릿을 기반으로 pod를 생성하므로 deployment와 유사합니다.
pod가 항상 순서대로 생성이 되고 항상 고유한 이름이 붙게 됩니다. scale down,up, rolling update, role back, head less 기능이 있습니다. 

```
apiVersion: apps/v1
kind: StatefulSet
metadata:
    name: mysql
    labels:
        app: mysql
spec:
    template:
        metadata:
            labels:
                app: mysql
        spec:
            containers:
                - name: mysql
                  image: mysql
    replicas: 3
    selector:
        matchLabels:
            app: mysql
    serviceName: mysql-h
    podManagementPolicy: Parallel
```

statefulset에서 pod가 순서대로 배포되고 삭제되는 것을 따르고 싶지 않을 때 
 podManagementPolicy: Parallel을 사용합니다. 


## headless service

service는 loadbalancer 역할을 하기도 합니다. 
service는 cluster ip가 있고 dns가 있습니다.

사용자가 mysql 서비스를 read할 수 있지만 write할 수는 없습니다. 
wrtie하기 위해서는 master 서버만을 가리키도록 해야합니다.
각각의 pod에 도달할 수 있는 DNS entry 필요합니다. 이를 위한 것이 headless service 입니다.

headless service는 일반 service처럼 생성되지만 일반 service의 cluster ip처럼 고유한 ip가 존재하지 않습니다.
어떠한 load balancer도 하지 않습니다. 오직 dns 엔트리를 생성할 뿐 입니다. 각 pod 이름과 하위 도메인을 이용해서 dns 엔트리를 생성합니다.


headless none

```
apiVersion: v1
kind: Service
metadata:
  name: mysql-h
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

entry dns 만들기 위해 다음과 같은 두 가지를 추가해줘야 합니다.
subdomain: mysql-h
  hostname: mysql-pod
```
apiVersion: v1
kind: Pod
metadata:
  name: mysql-pod
  labels:
    app: mysql
spec:
  containers:
  - name: mysql
    image: mysql
  subdomain: mysql-h
  hostname: mysql-pod
```

이렇게 하면 똑같은 3개의 dns entry가 생성이 됩니다. 
`mysql-pod.mysql-h.default.svc.cluster.local`

- deployment
  
```
apiVersion: apps/v1
kind: Deployment
metadata:
    name: mysql-deployment
    labels:
        app: mysql
spec:
    template:
        metadata:
            labels:
                app: mysql
        spec:
            containers:
                - name: mysql
                  image: mysql
            subdomain: mysql-h
            hostname: mysql-pod

```

- statefulset
serviceName으로 headless service와 연결합니다.
  
```
apiVersion: apps/v1
kind: StatefulSet
metadata:
    name: mysql
    labels:
        app: mysql
spec:
    serviceName: mysql-h
    template:
        metadata:
            name: myapp-pod
            labels:
                app: mysql
        spec:
            containers:
                - name: mysql
                  image: mysql

```

 # storage in statefulset
여러 개의 pod가 하나의 pv를 공유하지 않고 각각의 pv를 사용한다면
 volumeClameTemplate을 satefulset template으로 옮기면 됩니다.

  ```
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql
          volumeMounts:
            - mountPath: /var/lib/mysql
              name: data-volume
  volumeClaimTemplates:
    - metadata:
        name: data-volume
      spec:
        accessModes:
          - ReadWriteOnce
        storageClassName: google-storage
        resource:
          requests:
            storage: 500Mi
```
pod가 사라졌다 다시 생겨나도 statefulset은 pvc나 관련 pv를 자동으로 삭제하지 않습니다.



